
                      --------------------------
                      chirpradio Developer Guide
                      --------------------------


Using Mercurial
---------------

To create a new local repository:
% hg clone http://chirpradio.googlecode.com/hg/ chirpradio

To pull updates into your local repository:
% hg pull

To push your changes into the master repository:
% hg push https://<your username>@chirpradio.googlecode.com/hg/

To get your GoogleCode.com password (needed to push changes):
http://code.google.com/hosting/settings

To push your changes to a temporary location so that other 
developers can review them before they get pushed into the master,
make yourself a clone.  When you're on the main source code page of 
the project, you'll see a link to Clones and under that there is a link 
to create your own clone.  This creates an isolated repository that you 
can safely push your changes to during development.  When your changes 
are ready, someone can easily pull them into the master repository.

For more information about Mercurial, see "Mercurial: The Definitive
Guide", by Bryan O'Sullivan.
http://hgbook.red-bean.com/


Prerequisites
-------------

Everything should run in Python 2.5 or greater
http://python.org/download/

Note: Recent Ubuntu Linux versions (at least after Jaunty) ship with Python 2.6.
Many have reported problems running the Google App Engine SDK with a non-2.5.* 
version of Python.  To install Python 2.5 without breaking the default Python
install, you can use this command:
% sudo apt-get install python2.5

Install the Google App Engine SDK from
http://code.google.com/appengine/downloads.html

If on Mac OS X be sure to start up the launcher once 
so that it prompts you to create symbolic links in /usr/local/google_appengine

Unlike the Google App Engine Python SDK for Mac OS X/Windows, the Linux version 
comes as a zip archive rather than an installer.  To install, just unpack the
archive into /usr/local/google_appengine.  Or you can unpack it to your home directory
and create a symlink in /usr/local/google_appengine.

You may need to install PyCrypto.  For more information about PyCrypto, see:
http://www.dlitz.net/software/pycrypto/

On a Debian/Ubuntu system, use this command:
% sudo apt-get install python-crypto

On a Mac OS X system *with* mac ports, type:
% sudo port install py25-crypto

However, if you used an installer from python.org on Mac OS X
then you need to grab the pycrypto source and run:
% sudo python setup.py install

NOTE: The Google App Engine SDK currently does not run inside a virtualenv.
This is a known bug.

To run the JavaScript lint tests (which will fail otherwise) 
you will need the jsl command line tool, aka javascript-lint.

On mac ports you can get this with:
% sudo port install javascript-lint

(probably something similar for Linux)

Running Locally
---------------
	
To start up a local server, run
% python manage.py runserver

Note: If you are running on a system with multiple versions of Python
installed, make sure that you are using the 2.5 version, e.g.:

% python2.5 manage.py runserver

You can reach your local server by going to http://localhost:8000/
in your web browser.

If you are running this server on a different computer, you need to run
the server with
% python manage.py [hostname or IP address]
or
% python manange.py [hostname or IP address]:[port number]
instead.  This tells Django that it should accept remote connections.

Below, we refer to local URLs like this:  http://HOST:PORT/some/url
You should replace "HOST:PORT" with the appropriate host name/port
combination.

To run all unit tests:
% python manage.py test

You can also use
% python manage.py test [application name]
to only run a single application's tests.



Adding a New Application
------------------------

Every application has a name that looks like this: "landing_page".
Your code lives in a directory with the same name.
Your templates go under the directory templates/[application name].
Your media files go under the directory media/[application name].

All of your URLs are automatically mapped to be under
http://HOST:PORT/appname/my/url

To make your URLs visible, you need to:
(1) Update the top-level urls.py to include your urls.
(2) Add your application to INSTALLED_APPS in settings.py.


Users and Authentication
------------------------

The chirpradio applications use custom middleware to enforce access
controls.  It will automatically take care of details like blocking
inactive users or redirecting unauthenticated users to the login page.

* Roles

Roles are a light-weight substitute for the standard Django auth module's
notion of groups.

The list of valid roles is hard-wired into auth/roles.py, so adding a
new role requires an updated version of the app to be pushed into
production.

* Access Policy

With only a very few exceptions, all of the URLs that are part of the
chirpradio applications are only accessible to signed-in users.  If an
unauthenticated user tries to visit such a URL, they will be
redirected to a login page, and then redirected back to the
originally-requested page after they have successfully signed in.
This behavior is controlled by custom middleware defined in
auth/middleware.py.

Access can be further restricted based on role using the decorators
defined in auth/decorators.py.  For example, this is how to define a
view that is only accessible to a user who has the role "volunteer
coordinator":

    from auth import roles
    from auth.decorators import require_role

    @require_role(roles.VOLUNTEER_COORDINATOR)
    def my_view(request):
        ... etc ...

* User Information

Our User object is defined in auth/models.py.  It is similar, but not
identical, to the stock Django User object.

For any incoming HttpRequest, the user attribute is automatically populated
with the logged-in user's User object.

    def my_hello_world_view(request):
        return HttpResponse('Hello %s!' % request.user)

Users are keyed on their email addresses:
    some_user = User.get_by_email(email_addr)

However, users are allowed to change their email address.
Applications should not put them in the datastore or otherwise assume
that they are invariant.

* Unit Testing

To simplify unit testing, the CHIRP authentication system is
integrated with Django's django.test.client module.  You can use the
login method to test against fake users with various characteristics.

    from django.test.client import Client

    my_client = Client()
    # You can set any of the User object's attributes here.
    my_client.login(email="test@test.com", roles=[role1, role2])
    response = my_client.get("/some/page/to/test")

For more information on unit testing in Django, please see
http://docs.djangoproject.com/en/1.0/topics/testing/

* Creating a New Local Test User

If you are running locally, you can create a test account by:

 1) Go to http://HOST:PORT/_ah/login

 2) Enter the email address that you want to use for testing, and check
    the "sign in as administrator" box.  Then click the "login" button.

 3) Go to http://HOST:PORT/auth/_bootstrap.  Hitting this URL will
    create a new user account and then immediately redirect you to a
    login page.

 4) Now log in using the email address that you chose in step 2 and the
    password "test".

The test user created by this method has superuser privileges, so you
should be able to add other test accounts by visiting
http://HOST:PORT/auth/

* Resetting a Local Test User's Password

Since a local development instance cannot send email, the normal
password recovery mechanism cannot be used for test accounts.  If you
forget a test account's password, you can

 1) Go to http://HOST:PORT/_ah/admin/datastore?kind=User

 2) Find the user whose password you wish to reset, then click on the
    "Key" hyperlink in order to edit it.

 3) Replace the entity's password attribute with the following:
      32e6e8b1d913ca40bd3f1d683ba65925bba1f559381f

 4) Click the "Save Changes" button.

You should now be able to log in as that user with the password "test".
